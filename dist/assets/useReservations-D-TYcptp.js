import{r as m,Y as R,U as l}from"./index-6E32DxFF.js";function $(){const d=m([]),n=m(!1),i=m(null),y=m(0),f=R(),h=r=>{const t={...r};return r.car&&(t.car={...r.car,plate_number:r.car.license_plate}),t};async function _(r=1,t="",e="all"){n.value=!0,i.value=null;const s=f.currentTenant?.id;if(!s){d.value=[],n.value=!1;return}try{let a=l.from("reservations").select("*, car:cars(*)",{count:"exact"}).eq("tenant_id",s);t&&(a=a.or(`reservation_number.ilike.%${t}%,client_name.ilike.%${t}%,client_cin.ilike.%${t}%`)),e&&e!=="all"&&(a=a.eq("status",e));const o=(r-1)*10,c=o+9,{data:u,count:w,error:v}=await a.range(o,c).order("created_at",{ascending:!1});if(v)throw v;d.value=(u||[]).map(h),y.value=w||0}catch(a){i.value=a.message}finally{n.value=!1}}async function p(r,t=1,e="all"){n.value=!0,i.value=null;const s=f.currentTenant?.id;s||console.warn("Fetching user reservations without tenant context");try{let a=l.from("reservations").select("*, car:cars(*)",{count:"exact"}).eq("user_id",r);s&&(a=a.eq("tenant_id",s)),e&&e!=="all"&&(a=a.eq("status",e));const o=(t-1)*10,c=o+9,{data:u,count:w,error:v}=await a.range(o,c).order("created_at",{ascending:!1});if(v)throw v;d.value=(u||[]).map(h),y.value=w||0}catch(a){i.value=a.message}finally{n.value=!1}}async function g(r){n.value=!0;const t=f.currentTenant?.id;try{let e=l.from("reservations").select("*, car:cars(*)").eq("id",r);t&&(e=e.eq("tenant_id",t));const{data:s,error:a}=await e.single();if(a)throw a;return h(s)}catch(e){return i.value=e.message,null}finally{n.value=!1}}async function q(r){n.value=!0;const t=f.currentTenant?.id;if(!t)throw n.value=!1,new Error("Cannot create reservation: No Tenant Context found.");try{const e={...r,tenant_id:t,reservation_number:`RES-${Date.now()}`};"user_id"in e&&delete e.user_id,e.reservation_number||(e.reservation_number=`RES-${Math.floor(Math.random()*1e6)}`);const{data:s,error:a}=await l.from("reservations").insert(e).select();if(a)throw a;return s?.[0]||null}catch(e){throw i.value=e.message,e}finally{n.value=!1}}async function b(r,t){n.value=!0;try{const{data:e,error:s}=await l.from("reservations").update(t).eq("id",r).select();if(s)throw s;return e?.[0]||null}catch(e){throw i.value=e.message,e}finally{n.value=!1}}async function E(r){n.value=!0;try{const{error:t}=await l.from("reservations").delete().eq("id",r);if(t)throw t}catch(t){throw i.value=t.message,t}finally{n.value=!1}}async function T(r,t,e,s){n.value=!0;const a=f.currentTenant?.id;try{let o=l.from("reservations").select("id").eq("car_id",r).in("status",["confirmed","active"]).lt("start_date",e).gt("end_date",t);a&&(o=o.eq("tenant_id",a)),s&&(o=o.neq("id",s));const{data:c,error:u}=await o;if(u)throw u;return c&&c.length===0}catch(o){return console.error("Availability check failed:",o),!1}finally{n.value=!1}}return{reservations:d,loading:n,error:i,total:y,fetchReservations:_,fetchUserReservations:p,getReservation:g,createReservation:q,updateReservation:b,deleteReservation:E,checkAvailability:T}}export{$ as u};
