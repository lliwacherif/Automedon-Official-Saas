-- AUTOMEDON COMPLETE DATABASE SETUP
-- This script sets up:
-- 1. Database Schema (Tables)
-- 2. Foreign Key Constraints (including CASCADE DELETE)
-- 3. Triggers (Resolution Number Generation)
-- 4. Storage Buckets & Policies (Public Anonymous Access)

-- ==========================================
-- 1. DATABASE SCHEMA
-- ==========================================

-- Admin Settings
CREATE TABLE IF NOT EXISTS public.admin_settings (
  id integer NOT NULL DEFAULT 1,
  password_hash text NOT NULL,
  updated_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
  username text UNIQUE,
  role text DEFAULT 'admin'::text,
  CONSTRAINT admin_settings_pkey PRIMARY KEY (id)
);

-- Cars
CREATE TABLE IF NOT EXISTS public.cars (
  id bigint GENERATED ALWAYS AS IDENTITY NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
  make text,
  model text NOT NULL,
  brand text CHECK (brand = ANY (ARRAY['Renault'::text, 'Dacia'::text, 'Skoda'::text, 'Hyundai'::text, 'Seat'::text, 'MG'::text, 'Mahindra'::text, 'Kia'::text, 'Honda'::text, 'Peugeot'::text, 'Cherry'::text, 'Geely'::text])),
  year integer,
  license_plate text NOT NULL UNIQUE,
  color text,
  price_per_day numeric,
  mileage integer NOT NULL DEFAULT 0,
  transmission text,
  seats integer,
  fuel_type text,
  description text,
  status text DEFAULT 'disponible'::text CHECK (status = ANY (ARRAY['disponible'::text, 'loue'::text, 'maintenance'::text])),
  image_url text,
  auto_manage_status boolean DEFAULT true,
  CONSTRAINT cars_pkey PRIMARY KEY (id)
);

-- Maintenance Records
CREATE TABLE IF NOT EXISTS public.maintenance_records (
  id bigint GENERATED ALWAYS AS IDENTITY NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
  updated_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
  car_id bigint NOT NULL,
  maintenance_type text NOT NULL CHECK (maintenance_type = ANY (ARRAY['OIL_CHANGE'::text, 'BRAKE_SERVICE'::text, 'REPAIR'::text, 'ROUTINE_CHECK'::text, 'LAVAGE'::text, 'ASSURANCE'::text, 'VIGNETTE'::text, 'LEASING'::text])),
  cost numeric NOT NULL DEFAULT 0,
  odometer integer NOT NULL,
  next_due_mileage integer,
  maintenance_date date NOT NULL,
  notes text,
  provider text,
  CONSTRAINT maintenance_records_pkey PRIMARY KEY (id),
  CONSTRAINT maintenance_records_car_id_fkey FOREIGN KEY (car_id) REFERENCES public.cars(id)
);

-- Reservations
CREATE TABLE IF NOT EXISTS public.reservations (
  id bigint GENERATED ALWAYS AS IDENTITY NOT NULL,
  -- Note: reservation_number will be auto-generated by trigger if NULL
  reservation_number character varying NOT NULL UNIQUE,
  user_id uuid,
  client_name character varying NOT NULL,
  client_cin character varying NOT NULL,
  client_phone character varying NOT NULL,
  client_email character varying,
  car_id bigint NOT NULL,
  start_date timestamp with time zone NOT NULL,
  end_date timestamp with time zone NOT NULL,
  pickup_time time without time zone,
  return_time time without time zone,
  pickup_location character varying,
  return_location character varying,
  duration_days integer NOT NULL,
  price_per_day numeric NOT NULL,
  total_price numeric NOT NULL,
  status character varying DEFAULT 'pending'::character varying CHECK (status::text = ANY (ARRAY['pending'::character varying::text, 'confirmed'::character varying::text, 'active'::character varying::text, 'completed'::character varying::text, 'cancelled'::character varying::text])),
  notes text,
  cancellation_reason text,
  cancelled_at timestamp with time zone,
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now(),
  advance_payment numeric NOT NULL DEFAULT 0,
  CONSTRAINT reservations_pkey PRIMARY KEY (id),
  CONSTRAINT reservations_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id),
  CONSTRAINT reservations_car_id_fkey FOREIGN KEY (car_id) REFERENCES public.cars(id)
);

-- Reservation Documents (with ON DELETE CASCADE)
CREATE TABLE IF NOT EXISTS public.reservation_documents (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  reservation_id bigint NOT NULL,
  file_url text NOT NULL,
  file_name text NOT NULL,
  uploaded_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT reservation_documents_pkey PRIMARY KEY (id),
  CONSTRAINT reservation_documents_reservation_id_fkey FOREIGN KEY (reservation_id) REFERENCES public.reservations(id) ON DELETE CASCADE
);

-- ==========================================
-- 2. TRIGGERS
-- ==========================================

-- Function to auto-generate reservation number
CREATE OR REPLACE FUNCTION generate_reservation_number()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.reservation_number IS NULL THEN
        NEW.reservation_number := 'RES-' || to_char(now(), 'YYYYMMDD') || '-' || 
                                  lpad(floor(random() * 10000)::text, 4, '0');
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger definition
DROP TRIGGER IF EXISTS set_reservation_number ON public.reservations;
CREATE TRIGGER set_reservation_number
BEFORE INSERT ON public.reservations
FOR EACH ROW
EXECUTE FUNCTION generate_reservation_number();

-- ==========================================
-- 3. STORAGE SETUP
-- ==========================================

-- Create Buckets ('car-images' and 'contracts')
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types) VALUES 
('car-images', 'car-images', true, 5242880, NULL),
('contracts', 'contracts', true, 5242880, NULL)
ON CONFLICT (id) DO UPDATE
SET public = true, file_size_limit = 5242880, allowed_mime_types = NULL;

-- Remove old policies to ensure clean state
DROP POLICY IF EXISTS "Public Read Access" ON storage.objects;
DROP POLICY IF EXISTS "Public Upload Access" ON storage.objects;
DROP POLICY IF EXISTS "Public Update Access" ON storage.objects;
DROP POLICY IF EXISTS "Public Delete Access" ON storage.objects;
DROP POLICY IF EXISTS "Public Read Access Contracts" ON storage.objects;
DROP POLICY IF EXISTS "Public Upload Access Contracts" ON storage.objects;
DROP POLICY IF EXISTS "Public Update Access Contracts" ON storage.objects;
DROP POLICY IF EXISTS "Public Delete Access Contracts" ON storage.objects;

-- Create Policies for 'car-images' (Public/Anonymous Access)
CREATE POLICY "Public Read Access Car Images" ON storage.objects FOR SELECT USING (bucket_id = 'car-images');
CREATE POLICY "Public Upload Access Car Images" ON storage.objects FOR INSERT WITH CHECK (bucket_id = 'car-images');
CREATE POLICY "Public Update Access Car Images" ON storage.objects FOR UPDATE USING (bucket_id = 'car-images');
CREATE POLICY "Public Delete Access Car Images" ON storage.objects FOR DELETE USING (bucket_id = 'car-images');

-- Create Policies for 'contracts' (Public/Anonymous Access)
CREATE POLICY "Public Read Access Contracts" ON storage.objects FOR SELECT USING (bucket_id = 'contracts');
CREATE POLICY "Public Upload Access Contracts" ON storage.objects FOR INSERT WITH CHECK (bucket_id = 'contracts');
CREATE POLICY "Public Update Access Contracts" ON storage.objects FOR UPDATE USING (bucket_id = 'contracts');
CREATE POLICY "Public Delete Access Contracts" ON storage.objects FOR DELETE USING (bucket_id = 'contracts');

-- Grant Permissions to 'anon' role (Required for custom auth)
GRANT USAGE ON SCHEMA storage TO anon;
GRANT ALL ON TABLE storage.objects TO anon;
GRANT ALL ON TABLE storage.buckets TO anon;
